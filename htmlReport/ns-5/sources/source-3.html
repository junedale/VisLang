


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > VisLangParser</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">core.interpreter.parser</a>
</div>

<h1>Coverage Summary for Class: VisLangParser (core.interpreter.parser)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">VisLangParser</td>
<td class="coverageStat">
  <span class="percent">
    40.6%
  </span>
  <span class="absValue">
    (13/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.9%
  </span>
  <span class="absValue">
    (162/741)
  </span>
</td>
</tr>
  <tr>
    <td class="name">VisLangParser$AssignActionContext</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$AssignmentContext</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$BinaryAddContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$BinaryMulContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$BlockContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$BodyContext</td>
<td class="coverageStat">
  <span class="percent">
    18.2%
  </span>
  <span class="absValue">
    (2/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (2/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$BooleanLiteralContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$CallStatContext</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$ComparisonContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$ComplexIfContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$DeclarationContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$DoubleLiteralContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$DoWhileStatContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$EqualityContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$ExprContext</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$ForStatContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$FunCallContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$FunDeclContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$GroupingsContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$IdentifierContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$IfStatContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$IntLiteralContext</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$LogicalAndContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$LogicalOrContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$NullContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$ParamsContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$PrintCallContext</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$PrintContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$PrintlnContext</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$ProgramContext</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$ReturnContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$SimpleIfContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$StatementContext</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (2/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.2%
  </span>
  <span class="absValue">
    (2/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$StringLiteralContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$UnaryMinContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$UnaryNotContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VisLangParser$WhileStatContext</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (41/286)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.4%
  </span>
  <span class="absValue">
    (190/1030)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;// Generated from java-escape by ANTLR 4.11.1
&nbsp;package core.interpreter.parser;
&nbsp;import org.antlr.v4.runtime.atn.*;
&nbsp;import org.antlr.v4.runtime.dfa.DFA;
&nbsp;import org.antlr.v4.runtime.*;
&nbsp;import org.antlr.v4.runtime.tree.*;
&nbsp;import java.util.List;
&nbsp;
&nbsp;@SuppressWarnings({&quot;all&quot;, &quot;warnings&quot;, &quot;unchecked&quot;, &quot;unused&quot;, &quot;cast&quot;, &quot;CheckReturnValue&quot;})
&nbsp;public class VisLangParser extends Parser {
<b class="fc">&nbsp;	static { RuntimeMetaData.checkVersion(&quot;4.11.1&quot;, RuntimeMetaData.VERSION); }</b>
&nbsp;
&nbsp;	protected static final DFA[] _decisionToDFA;
<b class="fc">&nbsp;	protected static final PredictionContextCache _sharedContextCache =</b>
&nbsp;		new PredictionContextCache();
&nbsp;	public static final int
&nbsp;		Lparen=1, Rparen=2, Lbrace=3, Rbrace=4, Comma=5, Colon=6, Semicolon=7, 
&nbsp;		Not=8, Mul=9, Div=10, Mod=11, Add=12, Sub=13, Langle=14, Rangle=15, Leq=16, 
&nbsp;		Req=17, Eqeq=18, Neq=19, Assign=20, Add_Assign=21, Sub_Assign=22, Mul_Assign=23, 
&nbsp;		Div_Assign=24, Mod_Assign=25, Fun=26, If=27, Else=28, For=29, Do=30, While=31, 
&nbsp;		Print=32, Println=33, Return=34, In=35, And=36, Or=37, Null=38, Boolean=39, 
&nbsp;		String=40, Integer=41, Double=42, Comment=43, Identifier=44, Whitespace=45;
&nbsp;	public static final int
&nbsp;		RULE_program = 0, RULE_body = 1, RULE_declaration = 2, RULE_funDecl = 3, 
&nbsp;		RULE_params = 4, RULE_statement = 5, RULE_ifStat = 6, RULE_simpleIf = 7, 
&nbsp;		RULE_complexIf = 8, RULE_doWhileStat = 9, RULE_whileStat = 10, RULE_forStat = 11, 
&nbsp;		RULE_callStat = 12, RULE_printCall = 13, RULE_funCall = 14, RULE_block = 15, 
&nbsp;		RULE_expr = 16, RULE_assignment = 17;
&nbsp;	private static String[] makeRuleNames() {
<b class="fc">&nbsp;		return new String[] {</b>
&nbsp;			&quot;program&quot;, &quot;body&quot;, &quot;declaration&quot;, &quot;funDecl&quot;, &quot;params&quot;, &quot;statement&quot;, &quot;ifStat&quot;, 
&nbsp;			&quot;simpleIf&quot;, &quot;complexIf&quot;, &quot;doWhileStat&quot;, &quot;whileStat&quot;, &quot;forStat&quot;, &quot;callStat&quot;, 
&nbsp;			&quot;printCall&quot;, &quot;funCall&quot;, &quot;block&quot;, &quot;expr&quot;, &quot;assignment&quot;
&nbsp;		};
&nbsp;	}
<b class="fc">&nbsp;	public static final String[] ruleNames = makeRuleNames();</b>
&nbsp;
&nbsp;	private static String[] makeLiteralNames() {
<b class="fc">&nbsp;		return new String[] {</b>
&nbsp;			null, &quot;&#39;(&#39;&quot;, &quot;&#39;)&#39;&quot;, &quot;&#39;{&#39;&quot;, &quot;&#39;}&#39;&quot;, &quot;&#39;,&#39;&quot;, &quot;&#39;:&#39;&quot;, &quot;&#39;;&#39;&quot;, &quot;&#39;!&#39;&quot;, &quot;&#39;*&#39;&quot;, 
&nbsp;			&quot;&#39;/&#39;&quot;, &quot;&#39;%&#39;&quot;, &quot;&#39;+&#39;&quot;, &quot;&#39;-&#39;&quot;, &quot;&#39;&lt;&#39;&quot;, &quot;&#39;&gt;&#39;&quot;, &quot;&#39;&lt;=&#39;&quot;, &quot;&#39;&gt;=&#39;&quot;, &quot;&#39;==&#39;&quot;, &quot;&#39;!=&#39;&quot;, 
&nbsp;			&quot;&#39;=&#39;&quot;, &quot;&#39;+=&#39;&quot;, &quot;&#39;-=&#39;&quot;, &quot;&#39;*=&#39;&quot;, &quot;&#39;/=&#39;&quot;, &quot;&#39;%=&#39;&quot;, &quot;&#39;fun&#39;&quot;, &quot;&#39;if&#39;&quot;, &quot;&#39;else&#39;&quot;, 
&nbsp;			&quot;&#39;for&#39;&quot;, &quot;&#39;do&#39;&quot;, &quot;&#39;while&#39;&quot;, &quot;&#39;print&#39;&quot;, &quot;&#39;println&#39;&quot;, &quot;&#39;return&#39;&quot;, &quot;&#39;in&#39;&quot;, 
&nbsp;			&quot;&#39;and&#39;&quot;, &quot;&#39;or&#39;&quot;, &quot;&#39;null&#39;&quot;
&nbsp;		};
&nbsp;	}
<b class="fc">&nbsp;	private static final String[] _LITERAL_NAMES = makeLiteralNames();</b>
&nbsp;	private static String[] makeSymbolicNames() {
<b class="fc">&nbsp;		return new String[] {</b>
&nbsp;			null, &quot;Lparen&quot;, &quot;Rparen&quot;, &quot;Lbrace&quot;, &quot;Rbrace&quot;, &quot;Comma&quot;, &quot;Colon&quot;, &quot;Semicolon&quot;, 
&nbsp;			&quot;Not&quot;, &quot;Mul&quot;, &quot;Div&quot;, &quot;Mod&quot;, &quot;Add&quot;, &quot;Sub&quot;, &quot;Langle&quot;, &quot;Rangle&quot;, &quot;Leq&quot;, 
&nbsp;			&quot;Req&quot;, &quot;Eqeq&quot;, &quot;Neq&quot;, &quot;Assign&quot;, &quot;Add_Assign&quot;, &quot;Sub_Assign&quot;, &quot;Mul_Assign&quot;, 
&nbsp;			&quot;Div_Assign&quot;, &quot;Mod_Assign&quot;, &quot;Fun&quot;, &quot;If&quot;, &quot;Else&quot;, &quot;For&quot;, &quot;Do&quot;, &quot;While&quot;, 
&nbsp;			&quot;Print&quot;, &quot;Println&quot;, &quot;Return&quot;, &quot;In&quot;, &quot;And&quot;, &quot;Or&quot;, &quot;Null&quot;, &quot;Boolean&quot;, &quot;String&quot;, 
&nbsp;			&quot;Integer&quot;, &quot;Double&quot;, &quot;Comment&quot;, &quot;Identifier&quot;, &quot;Whitespace&quot;
&nbsp;		};
&nbsp;	}
<b class="fc">&nbsp;	private static final String[] _SYMBOLIC_NAMES = makeSymbolicNames();</b>
<b class="fc">&nbsp;	public static final Vocabulary VOCABULARY = new VocabularyImpl(_LITERAL_NAMES, _SYMBOLIC_NAMES);</b>
&nbsp;
&nbsp;	/**
&nbsp;	 * @deprecated Use {@link #VOCABULARY} instead.
&nbsp;	 */
&nbsp;	@Deprecated
&nbsp;	public static final String[] tokenNames;
&nbsp;	static {
<b class="fc">&nbsp;		tokenNames = new String[_SYMBOLIC_NAMES.length];</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; tokenNames.length; i++) {</b>
<b class="fc">&nbsp;			tokenNames[i] = VOCABULARY.getLiteralName(i);</b>
<b class="fc">&nbsp;			if (tokenNames[i] == null) {</b>
<b class="fc">&nbsp;				tokenNames[i] = VOCABULARY.getSymbolicName(i);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (tokenNames[i] == null) {</b>
<b class="fc">&nbsp;				tokenNames[i] = &quot;&lt;INVALID&gt;&quot;;</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	@Deprecated
&nbsp;	public String[] getTokenNames() {
<b class="nc">&nbsp;		return tokenNames;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;
&nbsp;	public Vocabulary getVocabulary() {
<b class="nc">&nbsp;		return VOCABULARY;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
<b class="nc">&nbsp;	public String getGrammarFileName() { return &quot;java-escape&quot;; }</b>
&nbsp;
&nbsp;	@Override
<b class="nc">&nbsp;	public String[] getRuleNames() { return ruleNames; }</b>
&nbsp;
&nbsp;	@Override
<b class="nc">&nbsp;	public String getSerializedATN() { return _serializedATN; }</b>
&nbsp;
&nbsp;	@Override
<b class="fc">&nbsp;	public ATN getATN() { return _ATN; }</b>
&nbsp;
&nbsp;	public VisLangParser(TokenStream input) {
<b class="fc">&nbsp;		super(input);</b>
<b class="fc">&nbsp;		_interp = new ParserATNSimulator(this,_ATN,_decisionToDFA,_sharedContextCache);</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ProgramContext extends ParserRuleContext {
&nbsp;		public BodyContext body() {
<b class="nc">&nbsp;			return getRuleContext(BodyContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode EOF() { return getToken(VisLangParser.EOF, 0); }</b>
&nbsp;		public ProgramContext(ParserRuleContext parent, int invokingState) {
<b class="fc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_program; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitProgram(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final ProgramContext program() throws RecognitionException {
<b class="fc">&nbsp;		ProgramContext _localctx = new ProgramContext(_ctx, getState());</b>
<b class="fc">&nbsp;		enterRule(_localctx, 0, RULE_program);</b>
&nbsp;		try {
<b class="fc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="fc">&nbsp;			setState(36);</b>
<b class="fc">&nbsp;			body();</b>
<b class="fc">&nbsp;			setState(37);</b>
<b class="fc">&nbsp;			match(EOF);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="fc">&nbsp;			exitRule();</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class BodyContext extends ParserRuleContext {
&nbsp;		public List&lt;StatementContext&gt; statement() {
<b class="nc">&nbsp;			return getRuleContexts(StatementContext.class);</b>
&nbsp;		}
&nbsp;		public StatementContext statement(int i) {
<b class="nc">&nbsp;			return getRuleContext(StatementContext.class,i);</b>
&nbsp;		}
&nbsp;		public List&lt;DeclarationContext&gt; declaration() {
<b class="nc">&nbsp;			return getRuleContexts(DeclarationContext.class);</b>
&nbsp;		}
&nbsp;		public DeclarationContext declaration(int i) {
<b class="nc">&nbsp;			return getRuleContext(DeclarationContext.class,i);</b>
&nbsp;		}
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Semicolon() { return getTokens(VisLangParser.Semicolon); }</b>
&nbsp;		public TerminalNode Semicolon(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Semicolon, i);</b>
&nbsp;		}
&nbsp;		public BodyContext(ParserRuleContext parent, int invokingState) {
<b class="fc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_body; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitBody(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final BodyContext body() throws RecognitionException {
<b class="fc">&nbsp;		BodyContext _localctx = new BodyContext(_ctx, getState());</b>
<b class="fc">&nbsp;		enterRule(_localctx, 2, RULE_body);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="fc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="fc">&nbsp;			setState(44); </b>
<b class="fc">&nbsp;			_errHandler.sync(this);</b>
<b class="fc">&nbsp;			_la = _input.LA(1);</b>
&nbsp;			do {
&nbsp;				{
<b class="fc">&nbsp;				setState(44);</b>
<b class="fc">&nbsp;				_errHandler.sync(this);</b>
<b class="fc">&nbsp;				switch ( getInterpreter().adaptivePredict(_input,0,_ctx) ) {</b>
&nbsp;				case 1:
&nbsp;					{
<b class="fc">&nbsp;					setState(39);</b>
<b class="fc">&nbsp;					statement();</b>
&nbsp;					}
<b class="fc">&nbsp;					break;</b>
&nbsp;				case 2:
&nbsp;					{
<b class="nc">&nbsp;					setState(40);</b>
<b class="nc">&nbsp;					declaration();</b>
&nbsp;					}
<b class="nc">&nbsp;					break;</b>
&nbsp;				case 3:
&nbsp;					{
<b class="nc">&nbsp;					setState(41);</b>
<b class="nc">&nbsp;					expr(0);</b>
<b class="nc">&nbsp;					setState(42);</b>
<b class="nc">&nbsp;					match(Semicolon);</b>
&nbsp;					}
&nbsp;					break;
&nbsp;				}
&nbsp;				}
<b class="fc">&nbsp;				setState(46); </b>
<b class="fc">&nbsp;				_errHandler.sync(this);</b>
<b class="fc">&nbsp;				_la = _input.LA(1);</b>
<b class="fc">&nbsp;			} while ( ((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 26147425362178L) != 0 );</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="fc">&nbsp;			exitRule();</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class DeclarationContext extends ParserRuleContext {
&nbsp;		public FunDeclContext funDecl() {
<b class="nc">&nbsp;			return getRuleContext(FunDeclContext.class,0);</b>
&nbsp;		}
&nbsp;		public DeclarationContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_declaration; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitDeclaration(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final DeclarationContext declaration() throws RecognitionException {
<b class="nc">&nbsp;		DeclarationContext _localctx = new DeclarationContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 4, RULE_declaration);</b>
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(48);</b>
<b class="nc">&nbsp;			funDecl();</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class FunDeclContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode Fun() { return getToken(VisLangParser.Fun, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Identifier() { return getToken(VisLangParser.Identifier, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lbrace() { return getToken(VisLangParser.Lbrace, 0); }</b>
&nbsp;		public BlockContext block() {
<b class="nc">&nbsp;			return getRuleContext(BlockContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rbrace() { return getToken(VisLangParser.Rbrace, 0); }</b>
&nbsp;		public ParamsContext params() {
<b class="nc">&nbsp;			return getRuleContext(ParamsContext.class,0);</b>
&nbsp;		}
&nbsp;		public FunDeclContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_funDecl; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitFunDecl(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final FunDeclContext funDecl() throws RecognitionException {
<b class="nc">&nbsp;		FunDeclContext _localctx = new FunDeclContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 6, RULE_funDecl);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(50);</b>
<b class="nc">&nbsp;			match(Fun);</b>
<b class="nc">&nbsp;			setState(51);</b>
<b class="nc">&nbsp;			match(Identifier);</b>
<b class="nc">&nbsp;			setState(52);</b>
<b class="nc">&nbsp;			match(Lparen);</b>
<b class="nc">&nbsp;			setState(54);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
<b class="nc">&nbsp;			if (((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 26130581037314L) != 0) {</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(53);</b>
<b class="nc">&nbsp;				params();</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			setState(56);</b>
<b class="nc">&nbsp;			match(Rparen);</b>
<b class="nc">&nbsp;			setState(57);</b>
<b class="nc">&nbsp;			match(Lbrace);</b>
<b class="nc">&nbsp;			setState(58);</b>
<b class="nc">&nbsp;			block();</b>
<b class="nc">&nbsp;			setState(59);</b>
<b class="nc">&nbsp;			match(Rbrace);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ParamsContext extends ParserRuleContext {
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Identifier() { return getTokens(VisLangParser.Identifier); }</b>
&nbsp;		public TerminalNode Identifier(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Identifier, i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Comma() { return getTokens(VisLangParser.Comma); }</b>
&nbsp;		public TerminalNode Comma(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Comma, i);</b>
&nbsp;		}
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
&nbsp;		public ParamsContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_params; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitParams(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final ParamsContext params() throws RecognitionException {
<b class="nc">&nbsp;		ParamsContext _localctx = new ParamsContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 8, RULE_params);</b>
&nbsp;		try {
&nbsp;			int _alt;
<b class="nc">&nbsp;			setState(77);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			switch ( getInterpreter().adaptivePredict(_input,5,_ctx) ) {</b>
&nbsp;			case 1:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 1);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(61);</b>
<b class="nc">&nbsp;				match(Identifier);</b>
<b class="nc">&nbsp;				setState(66);</b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_alt = getInterpreter().adaptivePredict(_input,3,_ctx);</b>
<b class="nc">&nbsp;				while ( _alt!=1 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</b>
<b class="nc">&nbsp;					if ( _alt==1+1 ) {</b>
&nbsp;						{
&nbsp;						{
<b class="nc">&nbsp;						setState(62);</b>
<b class="nc">&nbsp;						match(Comma);</b>
<b class="nc">&nbsp;						setState(63);</b>
<b class="nc">&nbsp;						match(Identifier);</b>
&nbsp;						}
&nbsp;						} 
&nbsp;					}
<b class="nc">&nbsp;					setState(68);</b>
<b class="nc">&nbsp;					_errHandler.sync(this);</b>
<b class="nc">&nbsp;					_alt = getInterpreter().adaptivePredict(_input,3,_ctx);</b>
&nbsp;				}
&nbsp;				}
&nbsp;				break;
&nbsp;			case 2:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 2);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(69);</b>
<b class="nc">&nbsp;				expr(0);</b>
<b class="nc">&nbsp;				setState(74);</b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_alt = getInterpreter().adaptivePredict(_input,4,_ctx);</b>
<b class="nc">&nbsp;				while ( _alt!=1 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</b>
<b class="nc">&nbsp;					if ( _alt==1+1 ) {</b>
&nbsp;						{
&nbsp;						{
<b class="nc">&nbsp;						setState(70);</b>
<b class="nc">&nbsp;						match(Comma);</b>
<b class="nc">&nbsp;						setState(71);</b>
<b class="nc">&nbsp;						expr(0);</b>
&nbsp;						}
&nbsp;						} 
&nbsp;					}
<b class="nc">&nbsp;					setState(76);</b>
<b class="nc">&nbsp;					_errHandler.sync(this);</b>
<b class="nc">&nbsp;					_alt = getInterpreter().adaptivePredict(_input,4,_ctx);</b>
&nbsp;				}
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class StatementContext extends ParserRuleContext {
&nbsp;		public AssignmentContext assignment() {
<b class="nc">&nbsp;			return getRuleContext(AssignmentContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Semicolon() { return getToken(VisLangParser.Semicolon, 0); }</b>
&nbsp;		public IfStatContext ifStat() {
<b class="nc">&nbsp;			return getRuleContext(IfStatContext.class,0);</b>
&nbsp;		}
&nbsp;		public DoWhileStatContext doWhileStat() {
<b class="nc">&nbsp;			return getRuleContext(DoWhileStatContext.class,0);</b>
&nbsp;		}
&nbsp;		public WhileStatContext whileStat() {
<b class="nc">&nbsp;			return getRuleContext(WhileStatContext.class,0);</b>
&nbsp;		}
&nbsp;		public ForStatContext forStat() {
<b class="nc">&nbsp;			return getRuleContext(ForStatContext.class,0);</b>
&nbsp;		}
&nbsp;		public CallStatContext callStat() {
<b class="nc">&nbsp;			return getRuleContext(CallStatContext.class,0);</b>
&nbsp;		}
&nbsp;		public StatementContext(ParserRuleContext parent, int invokingState) {
<b class="fc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_statement; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitStatement(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final StatementContext statement() throws RecognitionException {
<b class="fc">&nbsp;		StatementContext _localctx = new StatementContext(_ctx, getState());</b>
<b class="fc">&nbsp;		enterRule(_localctx, 10, RULE_statement);</b>
&nbsp;		try {
<b class="fc">&nbsp;			setState(89);</b>
<b class="fc">&nbsp;			_errHandler.sync(this);</b>
<b class="fc">&nbsp;			switch ( getInterpreter().adaptivePredict(_input,6,_ctx) ) {</b>
&nbsp;			case 1:
<b class="fc">&nbsp;				enterOuterAlt(_localctx, 1);</b>
&nbsp;				{
<b class="fc">&nbsp;				setState(79);</b>
<b class="fc">&nbsp;				assignment();</b>
<b class="fc">&nbsp;				setState(80);</b>
<b class="fc">&nbsp;				match(Semicolon);</b>
&nbsp;				}
<b class="fc">&nbsp;				break;</b>
&nbsp;			case 2:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 2);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(82);</b>
<b class="nc">&nbsp;				ifStat();</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 3:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 3);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(83);</b>
<b class="nc">&nbsp;				doWhileStat();</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 4:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 4);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(84);</b>
<b class="nc">&nbsp;				whileStat();</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 5:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 5);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(85);</b>
<b class="nc">&nbsp;				forStat();</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 6:
<b class="fc">&nbsp;				enterOuterAlt(_localctx, 6);</b>
&nbsp;				{
<b class="fc">&nbsp;				setState(86);</b>
<b class="fc">&nbsp;				callStat();</b>
<b class="fc">&nbsp;				setState(87);</b>
<b class="fc">&nbsp;				match(Semicolon);</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="fc">&nbsp;			exitRule();</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class IfStatContext extends ParserRuleContext {
&nbsp;		public SimpleIfContext simpleIf() {
<b class="nc">&nbsp;			return getRuleContext(SimpleIfContext.class,0);</b>
&nbsp;		}
&nbsp;		public ComplexIfContext complexIf() {
<b class="nc">&nbsp;			return getRuleContext(ComplexIfContext.class,0);</b>
&nbsp;		}
&nbsp;		public IfStatContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_ifStat; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitIfStat(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final IfStatContext ifStat() throws RecognitionException {
<b class="nc">&nbsp;		IfStatContext _localctx = new IfStatContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 12, RULE_ifStat);</b>
&nbsp;		try {
<b class="nc">&nbsp;			setState(93);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			switch ( getInterpreter().adaptivePredict(_input,7,_ctx) ) {</b>
&nbsp;			case 1:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 1);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(91);</b>
<b class="nc">&nbsp;				simpleIf();</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 2:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 2);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(92);</b>
<b class="nc">&nbsp;				complexIf();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class SimpleIfContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode If() { return getToken(VisLangParser.If, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Lbrace() { return getTokens(VisLangParser.Lbrace); }</b>
&nbsp;		public TerminalNode Lbrace(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Lbrace, i);</b>
&nbsp;		}
&nbsp;		public List&lt;BlockContext&gt; block() {
<b class="nc">&nbsp;			return getRuleContexts(BlockContext.class);</b>
&nbsp;		}
&nbsp;		public BlockContext block(int i) {
<b class="nc">&nbsp;			return getRuleContext(BlockContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Rbrace() { return getTokens(VisLangParser.Rbrace); }</b>
&nbsp;		public TerminalNode Rbrace(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Rbrace, i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Else() { return getToken(VisLangParser.Else, 0); }</b>
&nbsp;		public SimpleIfContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_simpleIf; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitSimpleIf(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final SimpleIfContext simpleIf() throws RecognitionException {
<b class="nc">&nbsp;		SimpleIfContext _localctx = new SimpleIfContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 14, RULE_simpleIf);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(95);</b>
<b class="nc">&nbsp;			match(If);</b>
<b class="nc">&nbsp;			setState(96);</b>
<b class="nc">&nbsp;			match(Lparen);</b>
<b class="nc">&nbsp;			setState(97);</b>
<b class="nc">&nbsp;			expr(0);</b>
<b class="nc">&nbsp;			setState(98);</b>
<b class="nc">&nbsp;			match(Rparen);</b>
<b class="nc">&nbsp;			setState(99);</b>
<b class="nc">&nbsp;			match(Lbrace);</b>
<b class="nc">&nbsp;			setState(100);</b>
<b class="nc">&nbsp;			block();</b>
<b class="nc">&nbsp;			setState(101);</b>
<b class="nc">&nbsp;			match(Rbrace);</b>
<b class="nc">&nbsp;			setState(107);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
<b class="nc">&nbsp;			if (_la==Else) {</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(102);</b>
<b class="nc">&nbsp;				match(Else);</b>
<b class="nc">&nbsp;				setState(103);</b>
<b class="nc">&nbsp;				match(Lbrace);</b>
<b class="nc">&nbsp;				setState(104);</b>
<b class="nc">&nbsp;				block();</b>
<b class="nc">&nbsp;				setState(105);</b>
<b class="nc">&nbsp;				match(Rbrace);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ComplexIfContext extends ParserRuleContext {
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; If() { return getTokens(VisLangParser.If); }</b>
&nbsp;		public TerminalNode If(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.If, i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Lparen() { return getTokens(VisLangParser.Lparen); }</b>
&nbsp;		public TerminalNode Lparen(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Lparen, i);</b>
&nbsp;		}
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Rparen() { return getTokens(VisLangParser.Rparen); }</b>
&nbsp;		public TerminalNode Rparen(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Rparen, i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Lbrace() { return getTokens(VisLangParser.Lbrace); }</b>
&nbsp;		public TerminalNode Lbrace(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Lbrace, i);</b>
&nbsp;		}
&nbsp;		public List&lt;BlockContext&gt; block() {
<b class="nc">&nbsp;			return getRuleContexts(BlockContext.class);</b>
&nbsp;		}
&nbsp;		public BlockContext block(int i) {
<b class="nc">&nbsp;			return getRuleContext(BlockContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Rbrace() { return getTokens(VisLangParser.Rbrace); }</b>
&nbsp;		public TerminalNode Rbrace(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Rbrace, i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Else() { return getTokens(VisLangParser.Else); }</b>
&nbsp;		public TerminalNode Else(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Else, i);</b>
&nbsp;		}
&nbsp;		public ComplexIfContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_complexIf; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitComplexIf(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final ComplexIfContext complexIf() throws RecognitionException {
<b class="nc">&nbsp;		ComplexIfContext _localctx = new ComplexIfContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 16, RULE_complexIf);</b>
&nbsp;		int _la;
&nbsp;		try {
&nbsp;			int _alt;
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(109);</b>
<b class="nc">&nbsp;			match(If);</b>
<b class="nc">&nbsp;			setState(110);</b>
<b class="nc">&nbsp;			match(Lparen);</b>
<b class="nc">&nbsp;			setState(111);</b>
<b class="nc">&nbsp;			expr(0);</b>
<b class="nc">&nbsp;			setState(112);</b>
<b class="nc">&nbsp;			match(Rparen);</b>
<b class="nc">&nbsp;			setState(113);</b>
<b class="nc">&nbsp;			match(Lbrace);</b>
<b class="nc">&nbsp;			setState(114);</b>
<b class="nc">&nbsp;			block();</b>
<b class="nc">&nbsp;			setState(115);</b>
<b class="nc">&nbsp;			match(Rbrace);</b>
<b class="nc">&nbsp;			setState(127);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			_alt = getInterpreter().adaptivePredict(_input,9,_ctx);</b>
<b class="nc">&nbsp;			while ( _alt!=1 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</b>
<b class="nc">&nbsp;				if ( _alt==1+1 ) {</b>
&nbsp;					{
&nbsp;					{
<b class="nc">&nbsp;					setState(116);</b>
<b class="nc">&nbsp;					match(Else);</b>
<b class="nc">&nbsp;					setState(117);</b>
<b class="nc">&nbsp;					match(If);</b>
<b class="nc">&nbsp;					setState(118);</b>
<b class="nc">&nbsp;					match(Lparen);</b>
<b class="nc">&nbsp;					setState(119);</b>
<b class="nc">&nbsp;					expr(0);</b>
<b class="nc">&nbsp;					setState(120);</b>
<b class="nc">&nbsp;					match(Rparen);</b>
<b class="nc">&nbsp;					setState(121);</b>
<b class="nc">&nbsp;					match(Lbrace);</b>
<b class="nc">&nbsp;					setState(122);</b>
<b class="nc">&nbsp;					block();</b>
<b class="nc">&nbsp;					setState(123);</b>
<b class="nc">&nbsp;					match(Rbrace);</b>
&nbsp;					}
&nbsp;					} 
&nbsp;				}
<b class="nc">&nbsp;				setState(129);</b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_alt = getInterpreter().adaptivePredict(_input,9,_ctx);</b>
&nbsp;			}
<b class="nc">&nbsp;			setState(135);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
<b class="nc">&nbsp;			if (_la==Else) {</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(130);</b>
<b class="nc">&nbsp;				match(Else);</b>
<b class="nc">&nbsp;				setState(131);</b>
<b class="nc">&nbsp;				match(Lbrace);</b>
<b class="nc">&nbsp;				setState(132);</b>
<b class="nc">&nbsp;				block();</b>
<b class="nc">&nbsp;				setState(133);</b>
<b class="nc">&nbsp;				match(Rbrace);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class DoWhileStatContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode Do() { return getToken(VisLangParser.Do, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lbrace() { return getToken(VisLangParser.Lbrace, 0); }</b>
&nbsp;		public BlockContext block() {
<b class="nc">&nbsp;			return getRuleContext(BlockContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rbrace() { return getToken(VisLangParser.Rbrace, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode While() { return getToken(VisLangParser.While, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Semicolon() { return getToken(VisLangParser.Semicolon, 0); }</b>
&nbsp;		public DoWhileStatContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_doWhileStat; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitDoWhileStat(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final DoWhileStatContext doWhileStat() throws RecognitionException {
<b class="nc">&nbsp;		DoWhileStatContext _localctx = new DoWhileStatContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 18, RULE_doWhileStat);</b>
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(137);</b>
<b class="nc">&nbsp;			match(Do);</b>
<b class="nc">&nbsp;			setState(138);</b>
<b class="nc">&nbsp;			match(Lbrace);</b>
<b class="nc">&nbsp;			setState(139);</b>
<b class="nc">&nbsp;			block();</b>
<b class="nc">&nbsp;			setState(140);</b>
<b class="nc">&nbsp;			match(Rbrace);</b>
<b class="nc">&nbsp;			setState(141);</b>
<b class="nc">&nbsp;			match(While);</b>
<b class="nc">&nbsp;			setState(142);</b>
<b class="nc">&nbsp;			match(Lparen);</b>
<b class="nc">&nbsp;			setState(143);</b>
<b class="nc">&nbsp;			expr(0);</b>
<b class="nc">&nbsp;			setState(144);</b>
<b class="nc">&nbsp;			match(Rparen);</b>
<b class="nc">&nbsp;			setState(145);</b>
<b class="nc">&nbsp;			match(Semicolon);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class WhileStatContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode While() { return getToken(VisLangParser.While, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lbrace() { return getToken(VisLangParser.Lbrace, 0); }</b>
&nbsp;		public BlockContext block() {
<b class="nc">&nbsp;			return getRuleContext(BlockContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rbrace() { return getToken(VisLangParser.Rbrace, 0); }</b>
&nbsp;		public WhileStatContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_whileStat; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitWhileStat(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final WhileStatContext whileStat() throws RecognitionException {
<b class="nc">&nbsp;		WhileStatContext _localctx = new WhileStatContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 20, RULE_whileStat);</b>
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(147);</b>
<b class="nc">&nbsp;			match(While);</b>
<b class="nc">&nbsp;			setState(148);</b>
<b class="nc">&nbsp;			match(Lparen);</b>
<b class="nc">&nbsp;			setState(149);</b>
<b class="nc">&nbsp;			expr(0);</b>
<b class="nc">&nbsp;			setState(150);</b>
<b class="nc">&nbsp;			match(Rparen);</b>
<b class="nc">&nbsp;			setState(151);</b>
<b class="nc">&nbsp;			match(Lbrace);</b>
<b class="nc">&nbsp;			setState(152);</b>
<b class="nc">&nbsp;			block();</b>
<b class="nc">&nbsp;			setState(153);</b>
<b class="nc">&nbsp;			match(Rbrace);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ForStatContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode For() { return getToken(VisLangParser.For, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode In() { return getToken(VisLangParser.In, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lbrace() { return getToken(VisLangParser.Lbrace, 0); }</b>
&nbsp;		public BlockContext block() {
<b class="nc">&nbsp;			return getRuleContext(BlockContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rbrace() { return getToken(VisLangParser.Rbrace, 0); }</b>
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Identifier() { return getTokens(VisLangParser.Identifier); }</b>
&nbsp;		public TerminalNode Identifier(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Identifier, i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Integer() { return getTokens(VisLangParser.Integer); }</b>
&nbsp;		public TerminalNode Integer(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Integer, i);</b>
&nbsp;		}
&nbsp;		public AssignmentContext assignment() {
<b class="nc">&nbsp;			return getRuleContext(AssignmentContext.class,0);</b>
&nbsp;		}
&nbsp;		public ForStatContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_forStat; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitForStat(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final ForStatContext forStat() throws RecognitionException {
<b class="nc">&nbsp;		ForStatContext _localctx = new ForStatContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 22, RULE_forStat);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(155);</b>
<b class="nc">&nbsp;			match(For);</b>
<b class="nc">&nbsp;			setState(156);</b>
<b class="nc">&nbsp;			match(Lparen);</b>
<b class="nc">&nbsp;			setState(160);</b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			switch ( getInterpreter().adaptivePredict(_input,11,_ctx) ) {</b>
&nbsp;			case 1:
&nbsp;				{
<b class="nc">&nbsp;				setState(157);</b>
<b class="nc">&nbsp;				assignment();</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 2:
&nbsp;				{
<b class="nc">&nbsp;				setState(158);</b>
<b class="nc">&nbsp;				match(Identifier);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 3:
&nbsp;				{
<b class="nc">&nbsp;				setState(159);</b>
<b class="nc">&nbsp;				match(Integer);</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
<b class="nc">&nbsp;			setState(162);</b>
<b class="nc">&nbsp;			match(In);</b>
<b class="nc">&nbsp;			setState(163);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
<b class="nc">&nbsp;			if ( !(_la==Integer || _la==Identifier) ) {</b>
<b class="nc">&nbsp;			_errHandler.recoverInline(this);</b>
&nbsp;			}
&nbsp;			else {
<b class="nc">&nbsp;				if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="nc">&nbsp;				_errHandler.reportMatch(this);</b>
<b class="nc">&nbsp;				consume();</b>
&nbsp;			}
<b class="nc">&nbsp;			setState(164);</b>
<b class="nc">&nbsp;			match(Rparen);</b>
<b class="nc">&nbsp;			setState(165);</b>
<b class="nc">&nbsp;			match(Lbrace);</b>
<b class="nc">&nbsp;			setState(166);</b>
<b class="nc">&nbsp;			block();</b>
<b class="nc">&nbsp;			setState(167);</b>
<b class="nc">&nbsp;			match(Rbrace);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class CallStatContext extends ParserRuleContext {
&nbsp;		public PrintCallContext printCall() {
<b class="nc">&nbsp;			return getRuleContext(PrintCallContext.class,0);</b>
&nbsp;		}
&nbsp;		public FunCallContext funCall() {
<b class="nc">&nbsp;			return getRuleContext(FunCallContext.class,0);</b>
&nbsp;		}
&nbsp;		public CallStatContext(ParserRuleContext parent, int invokingState) {
<b class="fc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_callStat; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitCallStat(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final CallStatContext callStat() throws RecognitionException {
<b class="fc">&nbsp;		CallStatContext _localctx = new CallStatContext(_ctx, getState());</b>
<b class="fc">&nbsp;		enterRule(_localctx, 24, RULE_callStat);</b>
&nbsp;		try {
<b class="fc">&nbsp;			setState(171);</b>
<b class="fc">&nbsp;			_errHandler.sync(this);</b>
<b class="fc">&nbsp;			switch (_input.LA(1)) {</b>
&nbsp;			case Print:
&nbsp;			case Println:
<b class="fc">&nbsp;				enterOuterAlt(_localctx, 1);</b>
&nbsp;				{
<b class="fc">&nbsp;				setState(169);</b>
<b class="fc">&nbsp;				printCall();</b>
&nbsp;				}
<b class="fc">&nbsp;				break;</b>
&nbsp;			case Identifier:
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 2);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(170);</b>
<b class="nc">&nbsp;				funCall();</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				throw new NoViableAltException(this);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="fc">&nbsp;			exitRule();</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class PrintCallContext extends ParserRuleContext {
&nbsp;		public PrintCallContext(ParserRuleContext parent, int invokingState) {
<b class="fc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_printCall; }</b>
&nbsp;	 
<b class="fc">&nbsp;		public PrintCallContext() { }</b>
&nbsp;		public void copyFrom(PrintCallContext ctx) {
<b class="fc">&nbsp;			super.copyFrom(ctx);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class PrintContext extends PrintCallContext {
<b class="nc">&nbsp;		public TerminalNode Print() { return getToken(VisLangParser.Print, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public PrintContext(PrintCallContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitPrint(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class PrintlnContext extends PrintCallContext {
<b class="nc">&nbsp;		public TerminalNode Println() { return getToken(VisLangParser.Println, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="fc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="fc">&nbsp;		public PrintlnContext(PrintCallContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitPrintln(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final PrintCallContext printCall() throws RecognitionException {
<b class="fc">&nbsp;		PrintCallContext _localctx = new PrintCallContext(_ctx, getState());</b>
<b class="fc">&nbsp;		enterRule(_localctx, 26, RULE_printCall);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="fc">&nbsp;			setState(185);</b>
<b class="fc">&nbsp;			_errHandler.sync(this);</b>
<b class="fc">&nbsp;			switch (_input.LA(1)) {</b>
&nbsp;			case Print:
<b class="nc">&nbsp;				_localctx = new PrintContext(_localctx);</b>
<b class="nc">&nbsp;				enterOuterAlt(_localctx, 1);</b>
&nbsp;				{
<b class="nc">&nbsp;				setState(173);</b>
<b class="nc">&nbsp;				match(Print);</b>
<b class="nc">&nbsp;				setState(174);</b>
<b class="nc">&nbsp;				match(Lparen);</b>
<b class="nc">&nbsp;				setState(176);</b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_la = _input.LA(1);</b>
<b class="nc">&nbsp;				if (((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 26130581037314L) != 0) {</b>
&nbsp;					{
<b class="nc">&nbsp;					setState(175);</b>
<b class="nc">&nbsp;					expr(0);</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				setState(178);</b>
<b class="nc">&nbsp;				match(Rparen);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case Println:
<b class="fc">&nbsp;				_localctx = new PrintlnContext(_localctx);</b>
<b class="fc">&nbsp;				enterOuterAlt(_localctx, 2);</b>
&nbsp;				{
<b class="fc">&nbsp;				setState(179);</b>
<b class="fc">&nbsp;				match(Println);</b>
<b class="fc">&nbsp;				setState(180);</b>
<b class="fc">&nbsp;				match(Lparen);</b>
<b class="fc">&nbsp;				setState(182);</b>
<b class="fc">&nbsp;				_errHandler.sync(this);</b>
<b class="fc">&nbsp;				_la = _input.LA(1);</b>
<b class="fc">&nbsp;				if (((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 26130581037314L) != 0) {</b>
&nbsp;					{
<b class="fc">&nbsp;					setState(181);</b>
<b class="fc">&nbsp;					expr(0);</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				setState(184);</b>
<b class="fc">&nbsp;				match(Rparen);</b>
&nbsp;				}
<b class="fc">&nbsp;				break;</b>
&nbsp;			default:
<b class="nc">&nbsp;				throw new NoViableAltException(this);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="fc">&nbsp;			exitRule();</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class FunCallContext extends ParserRuleContext {
<b class="nc">&nbsp;		public TerminalNode Identifier() { return getToken(VisLangParser.Identifier, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
&nbsp;		public ParamsContext params() {
<b class="nc">&nbsp;			return getRuleContext(ParamsContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
&nbsp;		public FunCallContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_funCall; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitFunCall(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final FunCallContext funCall() throws RecognitionException {
<b class="nc">&nbsp;		FunCallContext _localctx = new FunCallContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 28, RULE_funCall);</b>
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(187);</b>
<b class="nc">&nbsp;			match(Identifier);</b>
<b class="nc">&nbsp;			setState(188);</b>
<b class="nc">&nbsp;			match(Lparen);</b>
<b class="nc">&nbsp;			setState(189);</b>
<b class="nc">&nbsp;			params();</b>
<b class="nc">&nbsp;			setState(190);</b>
<b class="nc">&nbsp;			match(Rparen);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class BlockContext extends ParserRuleContext {
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public List&lt;TerminalNode&gt; Semicolon() { return getTokens(VisLangParser.Semicolon); }</b>
&nbsp;		public TerminalNode Semicolon(int i) {
<b class="nc">&nbsp;			return getToken(VisLangParser.Semicolon, i);</b>
&nbsp;		}
&nbsp;		public List&lt;StatementContext&gt; statement() {
<b class="nc">&nbsp;			return getRuleContexts(StatementContext.class);</b>
&nbsp;		}
&nbsp;		public StatementContext statement(int i) {
<b class="nc">&nbsp;			return getRuleContext(StatementContext.class,i);</b>
&nbsp;		}
&nbsp;		public BlockContext(ParserRuleContext parent, int invokingState) {
<b class="nc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_block; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitBlock(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final BlockContext block() throws RecognitionException {
<b class="nc">&nbsp;		BlockContext _localctx = new BlockContext(_ctx, getState());</b>
<b class="nc">&nbsp;		enterRule(_localctx, 30, RULE_block);</b>
&nbsp;		int _la;
&nbsp;		try {
<b class="nc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="nc">&nbsp;			setState(196); </b>
<b class="nc">&nbsp;			_errHandler.sync(this);</b>
<b class="nc">&nbsp;			_la = _input.LA(1);</b>
&nbsp;			do {
&nbsp;				{
<b class="nc">&nbsp;				setState(196);</b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				switch ( getInterpreter().adaptivePredict(_input,16,_ctx) ) {</b>
&nbsp;				case 1:
&nbsp;					{
<b class="nc">&nbsp;					setState(192);</b>
<b class="nc">&nbsp;					expr(0);</b>
<b class="nc">&nbsp;					setState(193);</b>
<b class="nc">&nbsp;					match(Semicolon);</b>
&nbsp;					}
<b class="nc">&nbsp;					break;</b>
&nbsp;				case 2:
&nbsp;					{
<b class="nc">&nbsp;					setState(195);</b>
<b class="nc">&nbsp;					statement();</b>
&nbsp;					}
&nbsp;					break;
&nbsp;				}
&nbsp;				}
<b class="nc">&nbsp;				setState(198); </b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_la = _input.LA(1);</b>
<b class="nc">&nbsp;			} while ( ((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 26147358253314L) != 0 );</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="nc">&nbsp;			exitRule();</b>
<b class="nc">&nbsp;		}</b>
<b class="nc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ExprContext extends ParserRuleContext {
&nbsp;		public ExprContext(ParserRuleContext parent, int invokingState) {
<b class="fc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_expr; }</b>
&nbsp;	 
<b class="fc">&nbsp;		public ExprContext() { }</b>
&nbsp;		public void copyFrom(ExprContext ctx) {
<b class="fc">&nbsp;			super.copyFrom(ctx);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class IdentifierContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Identifier() { return getToken(VisLangParser.Identifier, 0); }</b>
<b class="nc">&nbsp;		public IdentifierContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitIdentifier(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class BinaryMulContext extends ExprContext {
&nbsp;		public Token op;
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Mul() { return getToken(VisLangParser.Mul, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Div() { return getToken(VisLangParser.Div, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Mod() { return getToken(VisLangParser.Mod, 0); }</b>
<b class="nc">&nbsp;		public BinaryMulContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitBinaryMul(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ComparisonContext extends ExprContext {
&nbsp;		public Token op;
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Langle() { return getToken(VisLangParser.Langle, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Rangle() { return getToken(VisLangParser.Rangle, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Leq() { return getToken(VisLangParser.Leq, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Req() { return getToken(VisLangParser.Req, 0); }</b>
<b class="nc">&nbsp;		public ComparisonContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitComparison(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class IntLiteralContext extends ExprContext {
<b class="fc">&nbsp;		public TerminalNode Integer() { return getToken(VisLangParser.Integer, 0); }</b>
<b class="fc">&nbsp;		public IntLiteralContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitIntLiteral(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class LogicalAndContext extends ExprContext {
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode And() { return getToken(VisLangParser.And, 0); }</b>
<b class="nc">&nbsp;		public LogicalAndContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitLogicalAnd(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class AssignActionContext extends ExprContext {
&nbsp;		public Token op;
<b class="fc">&nbsp;		public TerminalNode Identifier() { return getToken(VisLangParser.Identifier, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="fc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Add_Assign() { return getToken(VisLangParser.Add_Assign, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Sub_Assign() { return getToken(VisLangParser.Sub_Assign, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Mul_Assign() { return getToken(VisLangParser.Mul_Assign, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Div_Assign() { return getToken(VisLangParser.Div_Assign, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Mod_Assign() { return getToken(VisLangParser.Mod_Assign, 0); }</b>
<b class="fc">&nbsp;		public AssignActionContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitAssignAction(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class NullContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Null() { return getToken(VisLangParser.Null, 0); }</b>
<b class="nc">&nbsp;		public NullContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitNull(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class StringLiteralContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode String() { return getToken(VisLangParser.String, 0); }</b>
<b class="nc">&nbsp;		public StringLiteralContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitStringLiteral(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class GroupingsContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Lparen() { return getToken(VisLangParser.Lparen, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Rparen() { return getToken(VisLangParser.Rparen, 0); }</b>
<b class="nc">&nbsp;		public GroupingsContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitGroupings(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class UnaryMinContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Sub() { return getToken(VisLangParser.Sub, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public UnaryMinContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitUnaryMin(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class DoubleLiteralContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Double() { return getToken(VisLangParser.Double, 0); }</b>
<b class="nc">&nbsp;		public DoubleLiteralContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitDoubleLiteral(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class LogicalOrContext extends ExprContext {
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Or() { return getToken(VisLangParser.Or, 0); }</b>
<b class="nc">&nbsp;		public LogicalOrContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitLogicalOr(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class BooleanLiteralContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Boolean() { return getToken(VisLangParser.Boolean, 0); }</b>
<b class="nc">&nbsp;		public BooleanLiteralContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitBooleanLiteral(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class EqualityContext extends ExprContext {
&nbsp;		public Token op;
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Eqeq() { return getToken(VisLangParser.Eqeq, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Neq() { return getToken(VisLangParser.Neq, 0); }</b>
<b class="nc">&nbsp;		public EqualityContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitEquality(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class ReturnContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Return() { return getToken(VisLangParser.Return, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public ReturnContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitReturn(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class UnaryNotContext extends ExprContext {
<b class="nc">&nbsp;		public TerminalNode Not() { return getToken(VisLangParser.Not, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
<b class="nc">&nbsp;		public UnaryNotContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitUnaryNot(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class BinaryAddContext extends ExprContext {
&nbsp;		public Token op;
&nbsp;		public List&lt;ExprContext&gt; expr() {
<b class="nc">&nbsp;			return getRuleContexts(ExprContext.class);</b>
&nbsp;		}
&nbsp;		public ExprContext expr(int i) {
<b class="nc">&nbsp;			return getRuleContext(ExprContext.class,i);</b>
&nbsp;		}
<b class="nc">&nbsp;		public TerminalNode Add() { return getToken(VisLangParser.Add, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Sub() { return getToken(VisLangParser.Sub, 0); }</b>
<b class="nc">&nbsp;		public BinaryAddContext(ExprContext ctx) { copyFrom(ctx); }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="nc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitBinaryAdd(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final ExprContext expr() throws RecognitionException {
<b class="nc">&nbsp;		return expr(0);</b>
&nbsp;	}
&nbsp;
&nbsp;	private ExprContext expr(int _p) throws RecognitionException {
<b class="fc">&nbsp;		ParserRuleContext _parentctx = _ctx;</b>
<b class="fc">&nbsp;		int _parentState = getState();</b>
<b class="fc">&nbsp;		ExprContext _localctx = new ExprContext(_ctx, _parentState);</b>
<b class="fc">&nbsp;		ExprContext _prevctx = _localctx;</b>
<b class="fc">&nbsp;		int _startState = 32;</b>
<b class="fc">&nbsp;		enterRecursionRule(_localctx, 32, RULE_expr, _p);</b>
&nbsp;		int _la;
&nbsp;		try {
&nbsp;			int _alt;
<b class="fc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="fc">&nbsp;			setState(220);</b>
<b class="fc">&nbsp;			_errHandler.sync(this);</b>
<b class="fc">&nbsp;			switch ( getInterpreter().adaptivePredict(_input,18,_ctx) ) {</b>
&nbsp;			case 1:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new UnaryNotContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
&nbsp;
<b class="nc">&nbsp;				setState(201);</b>
<b class="nc">&nbsp;				match(Not);</b>
<b class="nc">&nbsp;				setState(202);</b>
<b class="nc">&nbsp;				expr(17);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 2:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new UnaryMinContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(203);</b>
<b class="nc">&nbsp;				match(Sub);</b>
<b class="nc">&nbsp;				setState(204);</b>
<b class="nc">&nbsp;				expr(16);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 3:
&nbsp;				{
<b class="fc">&nbsp;				_localctx = new AssignActionContext(_localctx);</b>
<b class="fc">&nbsp;				_ctx = _localctx;</b>
<b class="fc">&nbsp;				_prevctx = _localctx;</b>
<b class="fc">&nbsp;				setState(205);</b>
<b class="fc">&nbsp;				match(Identifier);</b>
<b class="fc">&nbsp;				setState(206);</b>
<b class="fc">&nbsp;				((AssignActionContext)_localctx).op = _input.LT(1);</b>
<b class="fc">&nbsp;				_la = _input.LA(1);</b>
<b class="fc">&nbsp;				if ( !(((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 65011712L) != 0) ) {</b>
<b class="nc">&nbsp;					((AssignActionContext)_localctx).op = (Token)_errHandler.recoverInline(this);</b>
&nbsp;				}
&nbsp;				else {
<b class="fc">&nbsp;					if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="fc">&nbsp;					_errHandler.reportMatch(this);</b>
<b class="fc">&nbsp;					consume();</b>
&nbsp;				}
<b class="fc">&nbsp;				setState(207);</b>
<b class="fc">&nbsp;				expr(11);</b>
&nbsp;				}
<b class="fc">&nbsp;				break;</b>
&nbsp;			case 4:
&nbsp;				{
<b class="fc">&nbsp;				_localctx = new IntLiteralContext(_localctx);</b>
<b class="fc">&nbsp;				_ctx = _localctx;</b>
<b class="fc">&nbsp;				_prevctx = _localctx;</b>
<b class="fc">&nbsp;				setState(208);</b>
<b class="fc">&nbsp;				match(Integer);</b>
&nbsp;				}
<b class="fc">&nbsp;				break;</b>
&nbsp;			case 5:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new DoubleLiteralContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(209);</b>
<b class="nc">&nbsp;				match(Double);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 6:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new StringLiteralContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(210);</b>
<b class="nc">&nbsp;				match(String);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 7:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new BooleanLiteralContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(211);</b>
<b class="nc">&nbsp;				match(Boolean);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 8:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new IdentifierContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(212);</b>
<b class="nc">&nbsp;				match(Identifier);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 9:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new NullContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(213);</b>
<b class="nc">&nbsp;				match(Null);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 10:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new ReturnContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(214);</b>
<b class="nc">&nbsp;				match(Return);</b>
<b class="nc">&nbsp;				setState(215);</b>
<b class="nc">&nbsp;				expr(2);</b>
&nbsp;				}
<b class="nc">&nbsp;				break;</b>
&nbsp;			case 11:
&nbsp;				{
<b class="nc">&nbsp;				_localctx = new GroupingsContext(_localctx);</b>
<b class="nc">&nbsp;				_ctx = _localctx;</b>
<b class="nc">&nbsp;				_prevctx = _localctx;</b>
<b class="nc">&nbsp;				setState(216);</b>
<b class="nc">&nbsp;				match(Lparen);</b>
<b class="nc">&nbsp;				setState(217);</b>
<b class="nc">&nbsp;				expr(0);</b>
<b class="nc">&nbsp;				setState(218);</b>
<b class="nc">&nbsp;				match(Rparen);</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
<b class="fc">&nbsp;			_ctx.stop = _input.LT(-1);</b>
<b class="fc">&nbsp;			setState(242);</b>
<b class="fc">&nbsp;			_errHandler.sync(this);</b>
<b class="fc">&nbsp;			_alt = getInterpreter().adaptivePredict(_input,20,_ctx);</b>
<b class="fc">&nbsp;			while ( _alt!=2 &amp;&amp; _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {</b>
<b class="nc">&nbsp;				if ( _alt==1 ) {</b>
<b class="nc">&nbsp;					if ( _parseListeners!=null ) triggerExitRuleEvent();</b>
<b class="nc">&nbsp;					_prevctx = _localctx;</b>
&nbsp;					{
<b class="nc">&nbsp;					setState(240);</b>
<b class="nc">&nbsp;					_errHandler.sync(this);</b>
<b class="nc">&nbsp;					switch ( getInterpreter().adaptivePredict(_input,19,_ctx) ) {</b>
&nbsp;					case 1:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new BinaryMulContext(new ExprContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expr);</b>
<b class="nc">&nbsp;						setState(222);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 15))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 15)&quot;);</b>
<b class="nc">&nbsp;						setState(223);</b>
<b class="nc">&nbsp;						((BinaryMulContext)_localctx).op = _input.LT(1);</b>
<b class="nc">&nbsp;						_la = _input.LA(1);</b>
<b class="nc">&nbsp;						if ( !(((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 3584L) != 0) ) {</b>
<b class="nc">&nbsp;							((BinaryMulContext)_localctx).op = (Token)_errHandler.recoverInline(this);</b>
&nbsp;						}
&nbsp;						else {
<b class="nc">&nbsp;							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="nc">&nbsp;							_errHandler.reportMatch(this);</b>
<b class="nc">&nbsp;							consume();</b>
&nbsp;						}
<b class="nc">&nbsp;						setState(224);</b>
<b class="nc">&nbsp;						expr(16);</b>
&nbsp;						}
<b class="nc">&nbsp;						break;</b>
&nbsp;					case 2:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new BinaryAddContext(new ExprContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expr);</b>
<b class="nc">&nbsp;						setState(225);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 14))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 14)&quot;);</b>
<b class="nc">&nbsp;						setState(226);</b>
<b class="nc">&nbsp;						((BinaryAddContext)_localctx).op = _input.LT(1);</b>
<b class="nc">&nbsp;						_la = _input.LA(1);</b>
<b class="nc">&nbsp;						if ( !(_la==Add || _la==Sub) ) {</b>
<b class="nc">&nbsp;							((BinaryAddContext)_localctx).op = (Token)_errHandler.recoverInline(this);</b>
&nbsp;						}
&nbsp;						else {
<b class="nc">&nbsp;							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="nc">&nbsp;							_errHandler.reportMatch(this);</b>
<b class="nc">&nbsp;							consume();</b>
&nbsp;						}
<b class="nc">&nbsp;						setState(227);</b>
<b class="nc">&nbsp;						expr(15);</b>
&nbsp;						}
<b class="nc">&nbsp;						break;</b>
&nbsp;					case 3:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new ComparisonContext(new ExprContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expr);</b>
<b class="nc">&nbsp;						setState(228);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 13))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 13)&quot;);</b>
<b class="nc">&nbsp;						setState(229);</b>
<b class="nc">&nbsp;						((ComparisonContext)_localctx).op = _input.LT(1);</b>
<b class="nc">&nbsp;						_la = _input.LA(1);</b>
<b class="nc">&nbsp;						if ( !(((_la) &amp; ~0x3f) == 0 &amp;&amp; ((1L &lt;&lt; _la) &amp; 245760L) != 0) ) {</b>
<b class="nc">&nbsp;							((ComparisonContext)_localctx).op = (Token)_errHandler.recoverInline(this);</b>
&nbsp;						}
&nbsp;						else {
<b class="nc">&nbsp;							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="nc">&nbsp;							_errHandler.reportMatch(this);</b>
<b class="nc">&nbsp;							consume();</b>
&nbsp;						}
<b class="nc">&nbsp;						setState(230);</b>
<b class="nc">&nbsp;						expr(14);</b>
&nbsp;						}
<b class="nc">&nbsp;						break;</b>
&nbsp;					case 4:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new EqualityContext(new ExprContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expr);</b>
<b class="nc">&nbsp;						setState(231);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 12))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 12)&quot;);</b>
<b class="nc">&nbsp;						setState(232);</b>
<b class="nc">&nbsp;						((EqualityContext)_localctx).op = _input.LT(1);</b>
<b class="nc">&nbsp;						_la = _input.LA(1);</b>
<b class="nc">&nbsp;						if ( !(_la==Eqeq || _la==Neq) ) {</b>
<b class="nc">&nbsp;							((EqualityContext)_localctx).op = (Token)_errHandler.recoverInline(this);</b>
&nbsp;						}
&nbsp;						else {
<b class="nc">&nbsp;							if ( _input.LA(1)==Token.EOF ) matchedEOF = true;</b>
<b class="nc">&nbsp;							_errHandler.reportMatch(this);</b>
<b class="nc">&nbsp;							consume();</b>
&nbsp;						}
<b class="nc">&nbsp;						setState(233);</b>
<b class="nc">&nbsp;						expr(13);</b>
&nbsp;						}
<b class="nc">&nbsp;						break;</b>
&nbsp;					case 5:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new LogicalAndContext(new ExprContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expr);</b>
<b class="nc">&nbsp;						setState(234);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 10)&quot;);</b>
<b class="nc">&nbsp;						setState(235);</b>
<b class="nc">&nbsp;						match(And);</b>
<b class="nc">&nbsp;						setState(236);</b>
<b class="nc">&nbsp;						expr(11);</b>
&nbsp;						}
<b class="nc">&nbsp;						break;</b>
&nbsp;					case 6:
&nbsp;						{
<b class="nc">&nbsp;						_localctx = new LogicalOrContext(new ExprContext(_parentctx, _parentState));</b>
<b class="nc">&nbsp;						pushNewRecursionContext(_localctx, _startState, RULE_expr);</b>
<b class="nc">&nbsp;						setState(237);</b>
<b class="nc">&nbsp;						if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, &quot;precpred(_ctx, 9)&quot;);</b>
<b class="nc">&nbsp;						setState(238);</b>
<b class="nc">&nbsp;						match(Or);</b>
<b class="nc">&nbsp;						setState(239);</b>
<b class="nc">&nbsp;						expr(10);</b>
&nbsp;						}
&nbsp;						break;
&nbsp;					}
&nbsp;					} 
&nbsp;				}
<b class="nc">&nbsp;				setState(244);</b>
<b class="nc">&nbsp;				_errHandler.sync(this);</b>
<b class="nc">&nbsp;				_alt = getInterpreter().adaptivePredict(_input,20,_ctx);</b>
&nbsp;			}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="fc">&nbsp;			unrollRecursionContexts(_parentctx);</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	@SuppressWarnings(&quot;CheckReturnValue&quot;)
&nbsp;	public static class AssignmentContext extends ParserRuleContext {
<b class="fc">&nbsp;		public TerminalNode Identifier() { return getToken(VisLangParser.Identifier, 0); }</b>
<b class="nc">&nbsp;		public TerminalNode Assign() { return getToken(VisLangParser.Assign, 0); }</b>
&nbsp;		public ExprContext expr() {
<b class="fc">&nbsp;			return getRuleContext(ExprContext.class,0);</b>
&nbsp;		}
&nbsp;		public FunCallContext funCall() {
<b class="nc">&nbsp;			return getRuleContext(FunCallContext.class,0);</b>
&nbsp;		}
&nbsp;		public AssignmentContext(ParserRuleContext parent, int invokingState) {
<b class="fc">&nbsp;			super(parent, invokingState);</b>
&nbsp;		}
<b class="nc">&nbsp;		@Override public int getRuleIndex() { return RULE_assignment; }</b>
&nbsp;		@Override
&nbsp;		public &lt;T&gt; T accept(ParseTreeVisitor&lt;? extends T&gt; visitor) {
<b class="fc">&nbsp;			if ( visitor instanceof VisLangVisitor ) return ((VisLangVisitor&lt;? extends T&gt;)visitor).visitAssignment(this);</b>
<b class="nc">&nbsp;			else return visitor.visitChildren(this);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public final AssignmentContext assignment() throws RecognitionException {
<b class="fc">&nbsp;		AssignmentContext _localctx = new AssignmentContext(_ctx, getState());</b>
<b class="fc">&nbsp;		enterRule(_localctx, 34, RULE_assignment);</b>
&nbsp;		try {
<b class="fc">&nbsp;			enterOuterAlt(_localctx, 1);</b>
&nbsp;			{
<b class="fc">&nbsp;			setState(245);</b>
<b class="fc">&nbsp;			match(Identifier);</b>
<b class="fc">&nbsp;			setState(246);</b>
<b class="fc">&nbsp;			match(Assign);</b>
<b class="fc">&nbsp;			setState(249);</b>
<b class="fc">&nbsp;			_errHandler.sync(this);</b>
<b class="fc">&nbsp;			switch ( getInterpreter().adaptivePredict(_input,21,_ctx) ) {</b>
&nbsp;			case 1:
&nbsp;				{
<b class="fc">&nbsp;				setState(247);</b>
<b class="fc">&nbsp;				expr(0);</b>
&nbsp;				}
<b class="fc">&nbsp;				break;</b>
&nbsp;			case 2:
&nbsp;				{
<b class="nc">&nbsp;				setState(248);</b>
<b class="nc">&nbsp;				funCall();</b>
&nbsp;				}
&nbsp;				break;
&nbsp;			}
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		catch (RecognitionException re) {</b>
<b class="nc">&nbsp;			_localctx.exception = re;</b>
<b class="nc">&nbsp;			_errHandler.reportError(this, re);</b>
<b class="nc">&nbsp;			_errHandler.recover(this, re);</b>
&nbsp;		}
&nbsp;		finally {
<b class="fc">&nbsp;			exitRule();</b>
<b class="fc">&nbsp;		}</b>
<b class="fc">&nbsp;		return _localctx;</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
<b class="nc">&nbsp;		switch (ruleIndex) {</b>
&nbsp;		case 16:
<b class="nc">&nbsp;			return expr_sempred((ExprContext)_localctx, predIndex);</b>
&nbsp;		}
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;	private boolean expr_sempred(ExprContext _localctx, int predIndex) {
<b class="nc">&nbsp;		switch (predIndex) {</b>
&nbsp;		case 0:
<b class="nc">&nbsp;			return precpred(_ctx, 15);</b>
&nbsp;		case 1:
<b class="nc">&nbsp;			return precpred(_ctx, 14);</b>
&nbsp;		case 2:
<b class="nc">&nbsp;			return precpred(_ctx, 13);</b>
&nbsp;		case 3:
<b class="nc">&nbsp;			return precpred(_ctx, 12);</b>
&nbsp;		case 4:
<b class="nc">&nbsp;			return precpred(_ctx, 10);</b>
&nbsp;		case 5:
<b class="nc">&nbsp;			return precpred(_ctx, 9);</b>
&nbsp;		}
<b class="nc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	public static final String _serializedATN =
&nbsp;		&quot;\u0004\u0001-\u00fc\u0002\u0000\u0007\u0000\u0002\u0001\u0007\u0001\u0002&quot;+
&nbsp;		&quot;\u0002\u0007\u0002\u0002\u0003\u0007\u0003\u0002\u0004\u0007\u0004\u0002&quot;+
&nbsp;		&quot;\u0005\u0007\u0005\u0002\u0006\u0007\u0006\u0002\u0007\u0007\u0007\u0002&quot;+
&nbsp;		&quot;\b\u0007\b\u0002\t\u0007\t\u0002\n\u0007\n\u0002\u000b\u0007\u000b\u0002&quot;+
&nbsp;		&quot;\f\u0007\f\u0002\r\u0007\r\u0002\u000e\u0007\u000e\u0002\u000f\u0007\u000f&quot;+
&nbsp;		&quot;\u0002\u0010\u0007\u0010\u0002\u0011\u0007\u0011\u0001\u0000\u0001\u0000&quot;+
&nbsp;		&quot;\u0001\u0000\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001\u0001&quot;+
&nbsp;		&quot;\u0004\u0001-\b\u0001\u000b\u0001\f\u0001.\u0001\u0002\u0001\u0002\u0001&quot;+
&nbsp;		&quot;\u0003\u0001\u0003\u0001\u0003\u0001\u0003\u0003\u00037\b\u0003\u0001&quot;+
&nbsp;		&quot;\u0003\u0001\u0003\u0001\u0003\u0001\u0003\u0001\u0003\u0001\u0004\u0001&quot;+
&nbsp;		&quot;\u0004\u0001\u0004\u0005\u0004A\b\u0004\n\u0004\f\u0004D\t\u0004\u0001&quot;+
&nbsp;		&quot;\u0004\u0001\u0004\u0001\u0004\u0005\u0004I\b\u0004\n\u0004\f\u0004L\t&quot;+
&nbsp;		&quot;\u0004\u0003\u0004N\b\u0004\u0001\u0005\u0001\u0005\u0001\u0005\u0001&quot;+
&nbsp;		&quot;\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001\u0005\u0001&quot;+
&nbsp;		&quot;\u0005\u0003\u0005Z\b\u0005\u0001\u0006\u0001\u0006\u0003\u0006^\b\u0006&quot;+
&nbsp;		&quot;\u0001\u0007\u0001\u0007\u0001\u0007\u0001\u0007\u0001\u0007\u0001\u0007&quot;+
&nbsp;		&quot;\u0001\u0007\u0001\u0007\u0001\u0007\u0001\u0007\u0001\u0007\u0001\u0007&quot;+
&nbsp;		&quot;\u0003\u0007l\b\u0007\u0001\b\u0001\b\u0001\b\u0001\b\u0001\b\u0001\b&quot;+
&nbsp;		&quot;\u0001\b\u0001\b\u0001\b\u0001\b\u0001\b\u0001\b\u0001\b\u0001\b\u0001&quot;+
&nbsp;		&quot;\b\u0001\b\u0005\b~\b\b\n\b\f\b\u0081\t\b\u0001\b\u0001\b\u0001\b\u0001&quot;+
&nbsp;		&quot;\b\u0001\b\u0003\b\u0088\b\b\u0001\t\u0001\t\u0001\t\u0001\t\u0001\t\u0001&quot;+
&nbsp;		&quot;\t\u0001\t\u0001\t\u0001\t\u0001\t\u0001\n\u0001\n\u0001\n\u0001\n\u0001&quot;+
&nbsp;		&quot;\n\u0001\n\u0001\n\u0001\n\u0001\u000b\u0001\u000b\u0001\u000b\u0001\u000b&quot;+
&nbsp;		&quot;\u0001\u000b\u0003\u000b\u00a1\b\u000b\u0001\u000b\u0001\u000b\u0001\u000b&quot;+
&nbsp;		&quot;\u0001\u000b\u0001\u000b\u0001\u000b\u0001\u000b\u0001\f\u0001\f\u0003&quot;+
&nbsp;		&quot;\f\u00ac\b\f\u0001\r\u0001\r\u0001\r\u0003\r\u00b1\b\r\u0001\r\u0001\r&quot;+
&nbsp;		&quot;\u0001\r\u0001\r\u0003\r\u00b7\b\r\u0001\r\u0003\r\u00ba\b\r\u0001\u000e&quot;+
&nbsp;		&quot;\u0001\u000e\u0001\u000e\u0001\u000e\u0001\u000e\u0001\u000f\u0001\u000f&quot;+
&nbsp;		&quot;\u0001\u000f\u0001\u000f\u0004\u000f\u00c5\b\u000f\u000b\u000f\f\u000f&quot;+
&nbsp;		&quot;\u00c6\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001&quot;+
&nbsp;		&quot;\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001&quot;+
&nbsp;		&quot;\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001&quot;+
&nbsp;		&quot;\u0010\u0001\u0010\u0001\u0010\u0003\u0010\u00dd\b\u0010\u0001\u0010\u0001&quot;+
&nbsp;		&quot;\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001&quot;+
&nbsp;		&quot;\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001&quot;+
&nbsp;		&quot;\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0001\u0010\u0005\u0010\u00f1&quot;+
&nbsp;		&quot;\b\u0010\n\u0010\f\u0010\u00f4\t\u0010\u0001\u0011\u0001\u0011\u0001\u0011&quot;+
&nbsp;		&quot;\u0001\u0011\u0003\u0011\u00fa\b\u0011\u0001\u0011\u0003BJ\u007f\u0001&quot;+
&nbsp;		&quot; \u0012\u0000\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014\u0016\u0018&quot;+
&nbsp;		&quot;\u001a\u001c\u001e \&quot;\u0000\u0006\u0002\u0000)),,\u0001\u0000\u0015\u0019&quot;+
&nbsp;		&quot;\u0001\u0000\t\u000b\u0001\u0000\f\r\u0001\u0000\u000e\u0011\u0001\u0000&quot;+
&nbsp;		&quot;\u0012\u0013\u0112\u0000$\u0001\u0000\u0000\u0000\u0002,\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u00040\u0001\u0000\u0000\u0000\u00062\u0001\u0000\u0000\u0000\b&quot;+
&nbsp;		&quot;M\u0001\u0000\u0000\u0000\nY\u0001\u0000\u0000\u0000\f]\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u000e_\u0001\u0000\u0000\u0000\u0010m\u0001\u0000\u0000\u0000\u0012&quot;+
&nbsp;		&quot;\u0089\u0001\u0000\u0000\u0000\u0014\u0093\u0001\u0000\u0000\u0000\u0016&quot;+
&nbsp;		&quot;\u009b\u0001\u0000\u0000\u0000\u0018\u00ab\u0001\u0000\u0000\u0000\u001a&quot;+
&nbsp;		&quot;\u00b9\u0001\u0000\u0000\u0000\u001c\u00bb\u0001\u0000\u0000\u0000\u001e&quot;+
&nbsp;		&quot;\u00c4\u0001\u0000\u0000\u0000 \u00dc\u0001\u0000\u0000\u0000\&quot;\u00f5&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000$%\u0003\u0002\u0001\u0000%&amp;\u0005\u0000\u0000&quot;+
&nbsp;		&quot;\u0001&amp;\u0001\u0001\u0000\u0000\u0000\&#39;-\u0003\n\u0005\u0000(-\u0003\u0004&quot;+
&nbsp;		&quot;\u0002\u0000)*\u0003 \u0010\u0000*+\u0005\u0007\u0000\u0000+-\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000,\&#39;\u0001\u0000\u0000\u0000,(\u0001\u0000\u0000\u0000,)\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000-.\u0001\u0000\u0000\u0000.,\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;./\u0001\u0000\u0000\u0000/\u0003\u0001\u0000\u0000\u000001\u0003\u0006&quot;+
&nbsp;		&quot;\u0003\u00001\u0005\u0001\u0000\u0000\u000023\u0005\u001a\u0000\u0000&quot;+
&nbsp;		&quot;34\u0005,\u0000\u000046\u0005\u0001\u0000\u000057\u0003\b\u0004\u0000&quot;+
&nbsp;		&quot;65\u0001\u0000\u0000\u000067\u0001\u0000\u0000\u000078\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u000089\u0005\u0002\u0000\u00009:\u0005\u0003\u0000\u0000:;\u0003\u001e&quot;+
&nbsp;		&quot;\u000f\u0000;&lt;\u0005\u0004\u0000\u0000&lt;\u0007\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;=B\u0005,\u0000\u0000&gt;?\u0005\u0005\u0000\u0000?A\u0005,\u0000\u0000@&quot;+
&nbsp;		&quot;&gt;\u0001\u0000\u0000\u0000AD\u0001\u0000\u0000\u0000BC\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000B@\u0001\u0000\u0000\u0000CN\u0001\u0000\u0000\u0000DB\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000EJ\u0003 \u0010\u0000FG\u0005\u0005\u0000\u0000GI\u0003 \u0010&quot;+
&nbsp;		&quot;\u0000HF\u0001\u0000\u0000\u0000IL\u0001\u0000\u0000\u0000JK\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000JH\u0001\u0000\u0000\u0000KN\u0001\u0000\u0000\u0000LJ\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000M=\u0001\u0000\u0000\u0000ME\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;N\t\u0001\u0000\u0000\u0000OP\u0003\&quot;\u0011\u0000PQ\u0005\u0007\u0000&quot;+
&nbsp;		&quot;\u0000QZ\u0001\u0000\u0000\u0000RZ\u0003\f\u0006\u0000SZ\u0003\u0012\t&quot;+
&nbsp;		&quot;\u0000TZ\u0003\u0014\n\u0000UZ\u0003\u0016\u000b\u0000VW\u0003\u0018\f&quot;+
&nbsp;		&quot;\u0000WX\u0005\u0007\u0000\u0000XZ\u0001\u0000\u0000\u0000YO\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000YR\u0001\u0000\u0000\u0000YS\u0001\u0000\u0000\u0000YT\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000YU\u0001\u0000\u0000\u0000YV\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;Z\u000b\u0001\u0000\u0000\u0000[^\u0003\u000e\u0007\u0000\\^\u0003\u0010&quot;+
&nbsp;		&quot;\b\u0000][\u0001\u0000\u0000\u0000]\\\u0001\u0000\u0000\u0000^\r\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000_`\u0005\u001b\u0000\u0000`a\u0005\u0001\u0000\u0000&quot;+
&nbsp;		&quot;ab\u0003 \u0010\u0000bc\u0005\u0002\u0000\u0000cd\u0005\u0003\u0000\u0000&quot;+
&nbsp;		&quot;de\u0003\u001e\u000f\u0000ek\u0005\u0004\u0000\u0000fg\u0005\u001c\u0000&quot;+
&nbsp;		&quot;\u0000gh\u0005\u0003\u0000\u0000hi\u0003\u001e\u000f\u0000ij\u0005\u0004&quot;+
&nbsp;		&quot;\u0000\u0000jl\u0001\u0000\u0000\u0000kf\u0001\u0000\u0000\u0000kl\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000l\u000f\u0001\u0000\u0000\u0000mn\u0005\u001b\u0000&quot;+
&nbsp;		&quot;\u0000no\u0005\u0001\u0000\u0000op\u0003 \u0010\u0000pq\u0005\u0002\u0000&quot;+
&nbsp;		&quot;\u0000qr\u0005\u0003\u0000\u0000rs\u0003\u001e\u000f\u0000s\u007f\u0005&quot;+
&nbsp;		&quot;\u0004\u0000\u0000tu\u0005\u001c\u0000\u0000uv\u0005\u001b\u0000\u0000&quot;+
&nbsp;		&quot;vw\u0005\u0001\u0000\u0000wx\u0003 \u0010\u0000xy\u0005\u0002\u0000\u0000&quot;+
&nbsp;		&quot;yz\u0005\u0003\u0000\u0000z{\u0003\u001e\u000f\u0000{|\u0005\u0004\u0000&quot;+
&nbsp;		&quot;\u0000|~\u0001\u0000\u0000\u0000}t\u0001\u0000\u0000\u0000~\u0081\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u007f\u0080\u0001\u0000\u0000\u0000\u007f}\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\u0080\u0087\u0001\u0000\u0000\u0000\u0081\u007f\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\u0082\u0083\u0005\u001c\u0000\u0000\u0083\u0084\u0005\u0003&quot;+
&nbsp;		&quot;\u0000\u0000\u0084\u0085\u0003\u001e\u000f\u0000\u0085\u0086\u0005\u0004&quot;+
&nbsp;		&quot;\u0000\u0000\u0086\u0088\u0001\u0000\u0000\u0000\u0087\u0082\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\u0087\u0088\u0001\u0000\u0000\u0000\u0088\u0011\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\u0089\u008a\u0005\u001e\u0000\u0000\u008a\u008b\u0005\u0003&quot;+
&nbsp;		&quot;\u0000\u0000\u008b\u008c\u0003\u001e\u000f\u0000\u008c\u008d\u0005\u0004&quot;+
&nbsp;		&quot;\u0000\u0000\u008d\u008e\u0005\u001f\u0000\u0000\u008e\u008f\u0005\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u008f\u0090\u0003 \u0010\u0000\u0090\u0091\u0005\u0002\u0000&quot;+
&nbsp;		&quot;\u0000\u0091\u0092\u0005\u0007\u0000\u0000\u0092\u0013\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u0093\u0094\u0005\u001f\u0000\u0000\u0094\u0095\u0005\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0095\u0096\u0003 \u0010\u0000\u0096\u0097\u0005\u0002\u0000\u0000&quot;+
&nbsp;		&quot;\u0097\u0098\u0005\u0003\u0000\u0000\u0098\u0099\u0003\u001e\u000f\u0000&quot;+
&nbsp;		&quot;\u0099\u009a\u0005\u0004\u0000\u0000\u009a\u0015\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;\u009b\u009c\u0005\u001d\u0000\u0000\u009c\u00a0\u0005\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u009d\u00a1\u0003\&quot;\u0011\u0000\u009e\u00a1\u0005,\u0000\u0000\u009f&quot;+
&nbsp;		&quot;\u00a1\u0005)\u0000\u0000\u00a0\u009d\u0001\u0000\u0000\u0000\u00a0\u009e&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000\u00a0\u009f\u0001\u0000\u0000\u0000\u00a1\u00a2&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000\u00a2\u00a3\u0005#\u0000\u0000\u00a3\u00a4\u0007&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u00a4\u00a5\u0005\u0002\u0000\u0000\u00a5\u00a6\u0005&quot;+
&nbsp;		&quot;\u0003\u0000\u0000\u00a6\u00a7\u0003\u001e\u000f\u0000\u00a7\u00a8\u0005&quot;+
&nbsp;		&quot;\u0004\u0000\u0000\u00a8\u0017\u0001\u0000\u0000\u0000\u00a9\u00ac\u0003&quot;+
&nbsp;		&quot;\u001a\r\u0000\u00aa\u00ac\u0003\u001c\u000e\u0000\u00ab\u00a9\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\u00ab\u00aa\u0001\u0000\u0000\u0000\u00ac\u0019\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u0000\u00ad\u00ae\u0005 \u0000\u0000\u00ae\u00b0\u0005\u0001\u0000&quot;+
&nbsp;		&quot;\u0000\u00af\u00b1\u0003 \u0010\u0000\u00b0\u00af\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;\u00b0\u00b1\u0001\u0000\u0000\u0000\u00b1\u00b2\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;\u00b2\u00ba\u0005\u0002\u0000\u0000\u00b3\u00b4\u0005!\u0000\u0000\u00b4&quot;+
&nbsp;		&quot;\u00b6\u0005\u0001\u0000\u0000\u00b5\u00b7\u0003 \u0010\u0000\u00b6\u00b5&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000\u00b6\u00b7\u0001\u0000\u0000\u0000\u00b7\u00b8&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000\u00b8\u00ba\u0005\u0002\u0000\u0000\u00b9\u00ad&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000\u00b9\u00b3\u0001\u0000\u0000\u0000\u00ba\u001b&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000\u00bb\u00bc\u0005,\u0000\u0000\u00bc\u00bd\u0005&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u00bd\u00be\u0003\b\u0004\u0000\u00be\u00bf\u0005\u0002&quot;+
&nbsp;		&quot;\u0000\u0000\u00bf\u001d\u0001\u0000\u0000\u0000\u00c0\u00c1\u0003 \u0010&quot;+
&nbsp;		&quot;\u0000\u00c1\u00c2\u0005\u0007\u0000\u0000\u00c2\u00c5\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u00c3\u00c5\u0003\n\u0005\u0000\u00c4\u00c0\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;\u00c4\u00c3\u0001\u0000\u0000\u0000\u00c5\u00c6\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;\u00c6\u00c4\u0001\u0000\u0000\u0000\u00c6\u00c7\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;\u00c7\u001f\u0001\u0000\u0000\u0000\u00c8\u00c9\u0006\u0010\uffff\uffff&quot;+
&nbsp;		&quot;\u0000\u00c9\u00ca\u0005\b\u0000\u0000\u00ca\u00dd\u0003 \u0010\u0011&quot;+
&nbsp;		&quot;\u00cb\u00cc\u0005\r\u0000\u0000\u00cc\u00dd\u0003 \u0010\u0010\u00cd&quot;+
&nbsp;		&quot;\u00ce\u0005,\u0000\u0000\u00ce\u00cf\u0007\u0001\u0000\u0000\u00cf\u00dd&quot;+
&nbsp;		&quot;\u0003 \u0010\u000b\u00d0\u00dd\u0005)\u0000\u0000\u00d1\u00dd\u0005*&quot;+
&nbsp;		&quot;\u0000\u0000\u00d2\u00dd\u0005(\u0000\u0000\u00d3\u00dd\u0005\&#39;\u0000&quot;+
&nbsp;		&quot;\u0000\u00d4\u00dd\u0005,\u0000\u0000\u00d5\u00dd\u0005&amp;\u0000\u0000\u00d6&quot;+
&nbsp;		&quot;\u00d7\u0005\&quot;\u0000\u0000\u00d7\u00dd\u0003 \u0010\u0002\u00d8\u00d9&quot;+
&nbsp;		&quot;\u0005\u0001\u0000\u0000\u00d9\u00da\u0003 \u0010\u0000\u00da\u00db\u0005&quot;+
&nbsp;		&quot;\u0002\u0000\u0000\u00db\u00dd\u0001\u0000\u0000\u0000\u00dc\u00c8\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u00dc\u00cb\u0001\u0000\u0000\u0000\u00dc\u00cd\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u00dc\u00d0\u0001\u0000\u0000\u0000\u00dc\u00d1\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u00dc\u00d2\u0001\u0000\u0000\u0000\u00dc\u00d3\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u00dc\u00d4\u0001\u0000\u0000\u0000\u00dc\u00d5\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u00dc\u00d6\u0001\u0000\u0000\u0000\u00dc\u00d8\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u00dd\u00f2\u0001\u0000\u0000\u0000\u00de\u00df\n\u000f&quot;+
&nbsp;		&quot;\u0000\u0000\u00df\u00e0\u0007\u0002\u0000\u0000\u00e0\u00f1\u0003 \u0010&quot;+
&nbsp;		&quot;\u0010\u00e1\u00e2\n\u000e\u0000\u0000\u00e2\u00e3\u0007\u0003\u0000\u0000&quot;+
&nbsp;		&quot;\u00e3\u00f1\u0003 \u0010\u000f\u00e4\u00e5\n\r\u0000\u0000\u00e5\u00e6&quot;+
&nbsp;		&quot;\u0007\u0004\u0000\u0000\u00e6\u00f1\u0003 \u0010\u000e\u00e7\u00e8\n&quot;+
&nbsp;		&quot;\f\u0000\u0000\u00e8\u00e9\u0007\u0005\u0000\u0000\u00e9\u00f1\u0003 &quot;+
&nbsp;		&quot;\u0010\r\u00ea\u00eb\n\n\u0000\u0000\u00eb\u00ec\u0005$\u0000\u0000\u00ec&quot;+
&nbsp;		&quot;\u00f1\u0003 \u0010\u000b\u00ed\u00ee\n\t\u0000\u0000\u00ee\u00ef\u0005&quot;+
&nbsp;		&quot;%\u0000\u0000\u00ef\u00f1\u0003 \u0010\n\u00f0\u00de\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u00f0\u00e1\u0001\u0000\u0000\u0000\u00f0\u00e4\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u00f0\u00e7\u0001\u0000\u0000\u0000\u00f0\u00ea\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u00f0\u00ed\u0001\u0000\u0000\u0000\u00f1\u00f4\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u00f2\u00f0\u0001\u0000\u0000\u0000\u00f2\u00f3\u0001\u0000\u0000&quot;+
&nbsp;		&quot;\u0000\u00f3!\u0001\u0000\u0000\u0000\u00f4\u00f2\u0001\u0000\u0000\u0000&quot;+
&nbsp;		&quot;\u00f5\u00f6\u0005,\u0000\u0000\u00f6\u00f9\u0005\u0014\u0000\u0000\u00f7&quot;+
&nbsp;		&quot;\u00fa\u0003 \u0010\u0000\u00f8\u00fa\u0003\u001c\u000e\u0000\u00f9\u00f7&quot;+
&nbsp;		&quot;\u0001\u0000\u0000\u0000\u00f9\u00f8\u0001\u0000\u0000\u0000\u00fa#\u0001&quot;+
&nbsp;		&quot;\u0000\u0000\u0000\u0016,.6BJMY]k\u007f\u0087\u00a0\u00ab\u00b0\u00b6&quot;+
&nbsp;		&quot;\u00b9\u00c4\u00c6\u00dc\u00f0\u00f2\u00f9&quot;;
<b class="fc">&nbsp;	public static final ATN _ATN =</b>
<b class="fc">&nbsp;		new ATNDeserializer().deserialize(_serializedATN.toCharArray());</b>
&nbsp;	static {
<b class="fc">&nbsp;		_decisionToDFA = new DFA[_ATN.getNumberOfDecisions()];</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; _ATN.getNumberOfDecisions(); i++) {</b>
<b class="fc">&nbsp;			_decisionToDFA[i] = new DFA(_ATN.getDecisionState(i), i);</b>
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-01-11 19:42</div>
</div>
</body>
</html>
